#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2012 Björn Edström <be@bjrn.se>
# See license for details.

import optparse

import funkcast.weather as weather
import funkcast.MidiFile as MidiFile


def convert(report, idx, data_point, note_descr, absolute=True, invert=False):
    # to normalize we need the complete report
    weather = report[idx]
    value = float(weather[data_point])
    raw = [entry[data_point] for entry in report]
    length = max(raw) - min(raw)
    shifted = value - min(raw)
    #print raw
    # normalize data point [0,1]
    norm = shifted / length

    if data_point == 'wind-direction':
        if absolute:
            norm = value / 360.0
    elif data_point == 'wind-speed': # XXX
        if absolute:
            norm = value / 20.0
    elif data_point == 'temperature': # XXX
        if absolute:
            # -20 to 40
            temp = max(0, value + 20)
            # 0 to 60
            norm =  temp / 60.0
    elif data_point == 'pressure':
        # world records are low 870 and high 1085.7
        # standard atmosphere = 1013
        if absolute:
            norm = (value - 980) / 1040 # XXX
            if norm < 0:
                norm = 0
            elif norm > 1.0:
                norm = 1.0
    elif data_point == 'cloud-cover':
        if absolute:
            norm = value / 3.0
    elif data_point == 'rain':
        if absolute:
            norm = min(1.0, value / 10.0) # XXX

    if invert:
        norm = 1.0 - norm

    if note_descr == 'pitch':
        return int(40 + 12 * norm)
    if note_descr == 'volume':
        return int(50 + 50 * norm) # XXX: log
    if note_descr == 'time':
        return 0.5 + norm / 2
    if note_descr == 'duration':
        return 0.5 + norm / 2
    return norm


def main():
    # command line parsing
    parser = optparse.OptionParser(usage='usage: %prog [options] RULES LOCATION')
    parser.add_option("-f", "--file", dest="filename", default='output',
                      help="write report to FILE [%default]", metavar="FILE")
    parser.add_option("-t", "--tempo", dest="tempo", default=120, type='int',
                      help="tempo [%default]", metavar="BEAT")
    parser.add_option("-l", "--lilypond", dest="lilypond", default=False, action='store_true',
                      help="generate lilypond output")

    (options, args) = parser.parse_args()

    location = args[-1]

    # some defaults
    rules = {
        'duration': ('wind-speed', False, False),
        'volume': ('pressure', False, False),
        'time': ('temperature', False, True),
        'pitch': ('wind-direction', True, False)
    }

    rules_argv = args[:-1]
    for arg in rules_argv:
        try:
            note, point = arg.split('=')
            invert = point.startswith('-')
            absolute = point.endswith('*')
            point = point.strip('-*')
            rules[note] = (point, absolute, invert)
        except Exception, e:
            parser.error('failed to parse rule %r: %s' % (arg, e))

    # TODO: Add option for hour-by-hour report
    weather_data = weather.get_report(location)

    # generate music
    def _convert(i, note):
        point, absolute, invert = rules[note]
        return convert(weather_data, i, point, note, absolute=absolute, invert=invert)

    # by default, just createa a midi directly
    if not options.lilypond:
        midi = MidiFile.MIDIFile(1)
        midi.addTrackName(0, 0, 'Weather Track')
        midi.addTempo(0, 0, options.tempo)
        # midi.addProgramChange(0, 10, 0, 35)

        time = 0

        for idx in range(len(weather_data)):
            pitch = _convert(idx, 'pitch')
            duration = _convert(idx, 'duration')
            volume = _convert(idx, 'volume')

            midi.addNote(0, 0, pitch, time, duration, volume)

            time += _convert(idx, 'time')

        binfile = open(options.filename + '.mid', 'wb')
        midi.writeFile(binfile)
        binfile.close()
    # if --lilypond is given, create a score instead
    else:
        if options.filename == '-':
            out = sys.stdout
        else:
            out = file(options.filename + '.ly', 'w')
        print >> out, r"""
\version "2.12.3"
\score {
  \new Staff <<
    \new Voice \relative c' {
      \set midiInstrument = #"flute"
      \voiceOne
      \key c \major
      \time 2/2
"""
        time = 0
        # XXX
        some_scale = 'a4 ais b c cis4 d dis e f4 fis g gis'.split()
        for idx in range(len(weather_data)):
            pitch = _convert(idx, 'pitch')
            note = some_scale[pitch - 40]
            print >> out, note,
        print >> out, r"""
    }
  >>
  \layout { }
  \midi {
    \context {
      \Staff
      \remove "Staff_performer"
    }
    \context {
      \Voice
      \consists "Staff_performer"
    }
    \context {
      \Score
      tempoWholesPerMinute = #(ly:make-moment 72 2)
    }
  }
}
"""


if __name__ == '__main__':
    main()
